/*
 * usr_rs485_main.c
 *
 *  Created on: 2023/07/31
 *      Author: nosak
 */


/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "usr_system.h"
#include "rs485_com.h"

/* Public includes -----------------------------------------------------------*/

/* Public typedef ------------------------------------------------------------*/

/* Public define -------------------------------------------------------------*/

/* Public macro --------------------------------------------------------------*/

/* Public variables ----------------------------------------------------------*/

/* Public function prototypes ------------------------------------------------*/

/* Private includes ----------------------------------------------------------*/

/* Private variables ---------------------------------------------------------*/

/* Private typedef -----------------------------------------------------------*/
#define RS485_TX	GPIO_PIN_SET
#define RS485_RX	GPIO_PIN_RESET

/* Private typedef -----------------------------------------------------------*/

/* Private define ------------------------------------------------------------*/
#define RS485_ADD_ID	0x00
#define RS485_CMD_ID	0x03

#define RS485_ADD_BYTE	3
#define RS485_SUM_BYTE	2

#define RS485_COM_01_BYTE	6
#define RS485_COM_02_BYTE	7
#define RS485_COM_03_BYTE	3
#define RS485_COM_04_BYTE	7


/* Private macro -------------------------------------------------------------*/


/* Private variables ---------------------------------------------------------*/
typedef struct {
	uint8_t		resp_dt;
	uint8_t		status;
	uint8_t		status_err;
	uint8_t		sens_kind;
	uint16_t	slv_ver;
	uint16_t	sens_ver;
	float		sens_dt;
}SLAVE_DATA;

SLAVE_DATA slv_dt[RS485_AD_MAX];

/* Private variables ---------------------------------------------------------*/
#define  	RCV_BUF_SIZE 	128
uint8_t		rcv_dt[2];
uint8_t		rcvbuf[RCV_BUF_SIZE];
uint8_t		work_buf[RCV_BUF_SIZE];
uint8_t		rcvnum = 0;
uint8_t		rcv_wpt = 0;
uint8_t		rcv_rpt = 0;



/* Private variables ---------------------------------------------------------*/
#define TEXT_LENGTH		6
const char com_start_text[]   = "COM-ST\0";
const char res_start_text[]   = "RES-ST\0";
const char message_end_text[] = "MSGEND\0";
char comp_buf[TEXT_LENGTH+1];

/* Private variables ---------------------------------------------------------*/
typedef struct {
	uint8_t		command_id;
	uint8_t		command;
	uint8_t		reserved;
} RS485_COMMAND_01;

typedef struct {
	uint8_t		command_id;
	uint8_t		command;
	uint8_t		reserved;
} RS485_COMMAND_02;

typedef struct {
	uint8_t		command_id;
	uint8_t		command;
	uint8_t		reserved;
	uint8_t		measure_sw;
} RS485_COMMAND_03;

typedef struct {
	uint8_t		command_id;
	uint8_t		command;
	uint8_t		reserved;
	uint8_t		data_kind;
} RS485_COMMAND_04;


typedef union{
	RS485_COMMAND_01	cmd01;
	RS485_COMMAND_02	cmd02;
	RS485_COMMAND_03	cmd03;
	RS485_COMMAND_04	cmd04;
}RS485_CMD_UNION;


typedef struct {
	uint8_t				start_txt[TEXT_LENGTH];
	uint16_t			com_counter;

	uint8_t				address_id;
	uint8_t				dist_address;
	uint8_t				src_address;

	RS485_CMD_UNION		u;

	uint8_t				chksum_id;
	uint8_t				chksum;

	uint8_t				end_txt[TEXT_LENGTH];

}RS485_COMMAND_STRUCT;

/* Private variables ---------------------------------------------------------*/
typedef struct {
	uint8_t		command_id;
	uint8_t		command;
	uint8_t		command_resopns;
	uint8_t		error_detail;
	uint8_t		senser_kind;
} RS485_RESPONS_01;

typedef struct {
	uint8_t		command_id;
	uint8_t		command;
	uint8_t		command_resopns;
	uint16_t		slv_ver;
	uint16_t		sens_ver;
} RS485_RESPONS_02;

typedef struct {
	uint8_t		command_id;
	uint8_t		command;
	uint8_t		command_resopns;
} RS485_RESPONS_03;

typedef struct {
	uint8_t		command_id;
	uint8_t		command;
	uint8_t		command_resopns;
	float		data;
} RS485_RESPONS_04;


typedef union{
	RS485_RESPONS_01	res01;
	RS485_RESPONS_02	res02;
	RS485_RESPONS_03	res03;
	RS485_RESPONS_04	res04;
}RS485_RES_UNION;


typedef struct {
	uint8_t				start_txt[TEXT_LENGTH];
	uint16_t			com_counter;

	uint8_t				address_id;
	uint8_t				dist_address;
	uint8_t				src_address;

	RS485_RES_UNION		u;

	uint8_t				chksum_id;
	uint8_t				chksum;

	uint8_t				end_txt[TEXT_LENGTH];

}RS485_RESPONS_STRUCT;



/* Private variables ---------------------------------------------------------*/
typedef union{
	RS485_COMMAND_STRUCT	com;
	RS485_RESPONS_STRUCT	res;
}RS485_COMUNICATION;


#define 	RS485_MSG_MAX	sizeof(RS485_COMUNICATION)
uint8_t		cmd_mesg[RS485_MSG_MAX];
uint8_t		Res_mesg[RS485_MSG_MAX];
uint8_t		cmd_char[RS485_MSG_MAX];
uint8_t		cmd_ptr = 0;
uint8_t		res_ptr = 0;
uint16_t	com_counter = 0;

RS485_COMMAND_STRUCT	Com;
RS485_RESPONS_STRUCT	Res;


/* Private variables ---------------------------------------------------------*/
typedef struct{
	RA485_COMMAND		command;
	RA485_ADDRESS		address;
	uint8_t				sub1;
} CMD_MSG;


const CMD_MSG	com[] = {
	{ RS485_CMD_MESUR_DATA, RS485_AD_SLEVE01, 	0 },
//	{ RS485_CMD_STATUS, 	RS485_AD_SLEVE01, 	0 },
	{ RS485_CMD_STATUS, 	RS485_AD_SLEVE02, 	0 },
	{ RS485_CMD_VERSION, 	RS485_AD_SLEVE01, 	0 },
	{ RS485_CMD_VERSION, 	RS485_AD_SLEVE02, 	0 },
	{ RS485_CMD_MESUR, 		RS485_AD_SLEVE01, 	1 },
	{ RS485_CMD_MESUR, 		RS485_AD_SLEVE02, 	1 },
	{ RS485_CMD_STATUS, 	RS485_AD_SLEVE01, 	0 },
	{ RS485_CMD_STATUS, 	RS485_AD_SLEVE02, 	0 },
	{ RS485_CMD_MESUR_DATA, RS485_AD_SLEVE01, 	0 },
	{ RS485_CMD_MESUR_DATA, RS485_AD_SLEVE02, 	0 },
	{ RS485_CMD_MAX, 		0, 					0 }
};

/* Private variables ---------------------------------------------------------*/

typedef struct{
	uint8_t			address_id;
	uint8_t			command_id;
	uint8_t			chksum_id;
} COMMAND_FORM;

const COMMAND_FORM	com_form[] = {

		{ 0, 0, 0 },		// コマンドが１スタートのためダミーデータを入れる

		{ 0, 3, 9 },
		{ 0, 3, 10 },
		{ 0, 3, 6 },
		{ 0, 3, 10 },
};


typedef enum{
	COM_PROTOCOL_SEND,
	COM_PROTOCOL_RECIVE,
	COM_PROTOCOL_RESPONS

} COM_PROTOCOL_STEP;

typedef enum {
    COM_RCV_INIT = 0,
    COM_RCV_ADD_ID,
    COM_RCV_ADD_ID_DIST,
    COM_RCV_ADD_ID_SOURCE,
    COM_RCV_CMD_ID,
    COM_RCV_COMMAND,
    COM_RCV_CSUM_ID,
    COM_RCV_CSUM,
    COM_RCV_COMPLITE

}COM_STEP;

COM_STEP    com_step_flg;

/* Private function prototypes -----------------------------------------------*/
//RETURN_STATUS Send_rx485_cmd_message( CMD_MSG *com_msg );

RETURN_STATUS Send_rx485_cmd_message( CMD_MSG	 *com_msg );
UART_HandleTypeDef * Get_huart(void);

uint16_t  Get_end_test_pt(uint16_t num,uint8_t *buf );
RETURN_STATUS  Set_Res_Message(uint16_t num, uint8_t *src );
uint8_t Get_rcv_data(void);
uint8_t Get_command_chksum(uint8_t *start, uint8_t *end );


//==============================================================================
//
//==============================================================================
void Recive_rs485_prepaer(void)
{
	HAL_StatusTypeDef s;

		// 受信準備
		s= HAL_UART_Receive_IT(Get_huart(), rcv_dt, 1);

		switch(s){
		case HAL_OK:
			break;
		case HAL_ERROR:
		case HAL_BUSY:
		case HAL_TIMEOUT:
			// SKprintf("ERROR %s RS485 RECIVE = %d\r\n",UartList[SK_UART1_RS485].name, s);
			break;
		}
}

//==============================================================================
//
//==============================================================================
void Set_rcv_data(void)
{
    rcvbuf[rcv_wpt] = rcv_dt[0];
    rcvnum ++;
    rcv_wpt ++ ;
    if( rcv_wpt > RCV_BUF_SIZE ){
        rcv_wpt = 0;
    }
}

//==============================================================================
//　受信データ割込みコールバック
//==============================================================================
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
	Set_rcv_data();
	Recive_rs485_prepaer();
}


//==============================================================================
//
//==============================================================================
uint8_t Get_rcv_data(void)
{
    uint8_t dt;
    rcvnum --;
    dt =  rcvbuf[rcv_rpt];
    rcv_rpt ++ ;
    if( rcv_rpt > RCV_BUF_SIZE ){
        rcv_rpt = 0;
    }
    return dt;

}
//==============================================================================
//
//==============================================================================
void rs485_com_task(void)
{
		RETURN_STATUS		status = RET_TRUE;
		CMD_MSG				com_msg;
		COM_PROTOCOL_STEP	cp_step = COM_PROTOCOL_SEND;
		uint8_t 			num = 0;
		uint8_t dt;

		SKprintf("float=%d\r\n",sizeof(float))	;
		SKprintf("int=%d\r\n",sizeof(int))	;
		SKprintf("longt=%d\r\n",sizeof(long))	;

	while(1){

		switch( cp_step ){
		case COM_PROTOCOL_SEND:
			//SKprintf("rs485_com_task(001) cmd_ptr=%d \r\n",cmd_ptr);

			if( com[cmd_ptr].command != RS485_CMD_MAX ){
				//SKprintf("rs485_com_task() 001\r\n");
				com_msg.command = com[cmd_ptr].command;
				com_msg.address = com[cmd_ptr].address;
				com_msg.sub1 = com[cmd_ptr].sub1;
			}
			else{
				//SKprintf("rs485_com_task() 002\r\n");
				cmd_ptr = 0;
				com_msg.command = com[cmd_ptr].command;
				com_msg.address = com[cmd_ptr].address;
				com_msg.sub1 = com[cmd_ptr].sub1;
			}

			status = Send_rx485_cmd_message( &com_msg );


			if( status == RET_TRUE ){
				cp_step = COM_PROTOCOL_RECIVE;
                num = 0;
			}
			break;

		case COM_PROTOCOL_RECIVE:

			while( rcvnum  > 0 ){
				work_buf[num ++] = Get_rcv_data();
				//SKprintf("Get_end_test_pt() num=%d, dt=%02x\r\n",num,work_buf[(num-1)]);

				if( Get_end_test_pt(num, work_buf) != 0 ){
					SKprintf("Respons Recive\r\n");
					Set_Res_Message(num, work_buf);
					cp_step = COM_PROTOCOL_RESPONS;
					com_step_flg = COM_RCV_INIT;
					res_ptr = 0;

					break;
				}
			}
			break;

		case COM_PROTOCOL_RESPONS:
			status = RET_TRUE;
			switch( Res_mesg[TEXT_LENGTH+RS485_CMD_ID+1] ){
			case RS485_CMD_STATUS:
				SKprintf("RS485_CMD_STATUS\r\n");

				break;
			case RS485_CMD_VERSION:
				SKprintf("RS485_CMD_VERSION\r\n");

				break;
			case RS485_CMD_MESUR:
				SKprintf("RS485_CMD_MESUR\r\n");

				break;
			case RS485_CMD_MESUR_DATA:
				SKprintf("RS485_CMD_MESUR_DATA\r\n");

				break;
			default:
				status = RET_FALSE;
				SKprintf("ERROR Recive Command None \r\n");
				break;
			}

			if( status == RET_TRUE ){
				cp_step = COM_PROTOCOL_SEND;
				cmd_ptr ++;
				break;
			}

			break;

		default:
			break;

		}
	}
}

//==============================================================================
//
//==============================================================================
uint16_t  Get_end_test_pt(uint16_t num,uint8_t *buf )
{
	uint16_t	i;
	uint16_t	rtn;

	rtn = 0;

	for( i=0; i<num; i++){
		if( (i+TEXT_LENGTH) > num ){
			rtn = 0;
			//SKprintf("None\r\n");
			break;
		}
		else if( buf[i] == message_end_text[0]
				&& buf[i+1] == message_end_text[1]
				&& buf[i+2] == message_end_text[2]
				&& buf[i+3] == message_end_text[3]
				&& buf[i+4] == message_end_text[4]
				&& buf[i+5] == message_end_text[5] ){

			SKprintf("FIX\r\n");
			rtn = i;
			break;
		}
	}

	return rtn;
}
//==============================================================================
//
//==============================================================================
RETURN_STATUS  Set_Res_Message(uint16_t num, uint8_t *src)
{
	RETURN_STATUS	status = RET_TRUE;
	uint16_t	i;
	uint16_t	j;
	uint16_t	start;
	uint16_t	end;
	uint8_t		c[2];
	uint8_t		*pt;

	//-------------------------------------------------------
	// Command buffer Clesr
	//-------------------------------------------------------
	memset(&Res, 0, sizeof(RS485_RESPONS_STRUCT));


	//-------------------------------------------------------------
	// スタートテキスト検索
	//-------------------------------------------------------------
	start = 0xffff;
	for( i=0; i<num; i++){
		if( src[i] == res_start_text[0]
				&& src[i+1] == res_start_text[1]
				&& src[i+2] == res_start_text[2]
				&& src[i+3] == res_start_text[3]
				&& src[i+4] == res_start_text[4]
				&& src[i+5] == res_start_text[5] ){

			start = i;
			break;
		}
	}

	if( start == 0xffff ){
		status = RET_FALSE;
		SKprintf("Error : Respons Data start txt none \r\n");
	}

	//-------------------------------------------------------------
	// エンドテキスト検索
	//-------------------------------------------------------------
	end = 0xffff;
	for( i=0; i<num; i++){
		if( src[i] == message_end_text[0]
				&& src[i+1] == message_end_text[1]
				&& src[i+2] == message_end_text[2]
				&& src[i+3] == message_end_text[3]
				&& src[i+4] == message_end_text[4]
				&& src[i+5] == message_end_text[5] ){

			end = i+5+1;
			break;
		}
	}

	if( end == 0xffff ){
		status = RET_FALSE;
		SKprintf("Error : Respons Data end txt none \r\n");
	}

	//-------------------------------------------------------------
	// Res[]に転送
	//-------------------------------------------------------------
	pt = (uint8_t *)&Res;
	j = 0;
	for( i=start; i < end; i++){
		if( j < sizeof(RS485_RESPONS_STRUCT) ){
			pt[j] = src[i];
		}
		else{
			status = RET_FALSE;
			SKprintf("Error : Respons data size over\r\n");
		}
		j++;
	}

	//-------------------------------------------------------------
	// チェックサム確認
	//-------------------------------------------------------------
	if( Res.chksum != Get_command_chksum(&Res.address_id, &Res.chksum_id)){
		status = RET_FALSE;
		SKprintf("Error : Respons data chksum eoor");
	}

	//-------------------------------------------------------------
	// レスポンスデータをログ表示
	//-------------------------------------------------------------
	pt = (uint8_t *)&Res;

	for( i=0;  i < sizeof(RS485_RESPONS_STRUCT); i++ ){
		cmd_char[i] =  (uint8_t)((pt[i]<0x20||pt[i]>=0x7f)? '.': pt[i]);
	}

	SKprintf("\r\nRESPONS MESSAGE = \r\n ");
	for( i=0; i < sizeof(RS485_RESPONS_STRUCT); i++){
		SKprintf("%02x ", pt[i]);
	}
	SKprintf("\r\n ");
	c[1] = '\0';
	for( i=0; i < sizeof(RS485_RESPONS_STRUCT); i++){
		c[0] = cmd_char[i];
		SKprintf(" %s ", c);
	}
	SKprintf("\r\n");


	return status;

}
//==============================================================================
//
//=============================================================================
uint8_t Get_command_chksum(uint8_t *start, uint8_t *end )
{
	uint8_t	sum = 0;
	uint8_t	*pt;

	SKprintf("%p %p",start,end);
	pt = start;
	while( pt < end ){
		sum += *pt;
		SKprintf("pt=%02x ", *pt);
		pt ++;
	}
	SKprintf(" sum=%02x\r\n",sum);

	return sum;
}

//==============================================================================
//
//==============================================================================

RETURN_STATUS Send_rx485_cmd_message( CMD_MSG	 *com_msg )
{
	RETURN_STATUS	status = RET_TRUE;
	uint8_t		i   = 0;
	uint8_t		c[2];
	uint8_t		*pt;

	//-------------------------------------------------------
	// Command buffer Clesr
	//-------------------------------------------------------
	memset(&Com, 0, sizeof(RS485_COMMAND_STRUCT));

	//-------------------------------------------------------
	// START Text
	//-------------------------------------------------------
	for( i=0; i < TEXT_LENGTH; i++ ){
		Com.start_txt[i] = com_start_text[i];
	}

	//-------------------------------------------------------
	// 通信カウンタ
	//-------------------------------------------------------
	com_counter ++;
	Com.com_counter = com_counter;

	//-------------------------------------------------------
	// アドレス
	//-------------------------------------------------------
	Com.address_id = '#';
	Com.dist_address = com_msg->address;
	Com.src_address =  MY_RS485_ADDRESS;

	//-------------------------------------------------------
	// コマンド
	//-------------------------------------------------------
	switch(com_msg->command){
	case RS485_CMD_STATUS:
		Com.u.cmd01.command_id = '*';
		Com.u.cmd01.command = com_msg->command;
		break;
	case RS485_CMD_VERSION:
		Com.u.cmd02.command_id = '*';
		Com.u.cmd02.command = com_msg->command;
		break;
	case RS485_CMD_MESUR:
		Com.u.cmd03.command_id = '*';
		Com.u.cmd03.command = com_msg->command;
		Com.u.cmd03.measure_sw = com_msg->sub1;
		break;
	case RS485_CMD_MESUR_DATA:
		Com.u.cmd04.command_id = '*';
		Com.u.cmd04.command = com_msg->command;
		Com.u.cmd04.data_kind = com_msg->sub1;
		break;
	default:
		break;
	}

	//-------------------------------------------------------
	// チェックサム計算
	//-------------------------------------------------------
	Com.chksum_id = '$';
	Com.chksum = Get_command_chksum(&Com.address_id, &Com.chksum_id);

	//-------------------------------------------------------
	// END Text
	//-------------------------------------------------------
	for( i=0; i < TEXT_LENGTH; i++ ){
		Com.end_txt[i] = message_end_text[i];
	}

	//-------------------------------------------------------
	// デバック用ログ
	//-------------------------------------------------------
	pt = (uint8_t *)&Com;

	for( i=0;  i < sizeof(RS485_COMMAND_STRUCT); i++ ){
		cmd_char[i] =  (uint8_t)((pt[i]<0x20||pt[i]>=0x7f)? '.': pt[i]);
	}

	SKprintf("\r\nCOMMAND MESSAGE = \r\n ");
	for( i=0; i < sizeof(RS485_COMMAND_STRUCT); i++){
		SKprintf("%02x ", pt[i]);
	}
	SKprintf("\r\n ");
	c[1] = '\0';
	for( i=0; i < sizeof(RS485_COMMAND_STRUCT); i++){
		c[0] = cmd_char[i];
		SKprintf(" %s ", c);
	}
	SKprintf("\r\n");

	//-------------------------------------------------------
	// コマンド送信
	//-------------------------------------------------------
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, RS485_TX);
	status = Send_rs485((uint8_t *)&Com, sizeof(RS485_COMMAND_STRUCT) );
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, RS485_RX);


	return status;

}






